import os
import sys
import argparse
from openai import OpenAI
import json
from pathlib import Path
import time
import subprocess
from dotenv import load_dotenv

def validate_api_key(api_key):
    """Validate the API key format and strip any 'Bearer ' prefix"""
    if api_key.startswith('Bearer '):
        api_key = api_key.replace('Bearer ', '')
    return api_key.strip()

def test_api_connection(client):
    """Test the API connection with a simple request"""
    try:
        # Make a simple test request
        response = client.chat.completions.create(
            model="gpt-4o-mini-2024-07-18",
            messages=[{"role": "user", "content": "test"}],
            max_tokens=5
        )
        return True
    except Exception as e:
        print(f"API Connection Error: {str(e)}")
        return False

def get_summary(text, client, course_name):
    """Get a LaTeX formatted summary of the text using ChatGPT"""
    
    # Create a system message that matches the NotesService exactly
    system_msg = """You are an expert at creating detailed, well-structured lecture summaries in LaTeX format. Generate a complete LaTeX document that summarizes the lecture content. Follow these rules:

1. Use proper LaTeX sectioning (\\section, \\subsection)
2. Use proper LaTeX environments for different content types
3. Keep the LaTeX structure simple and valid
4. Don't include code blocks unless specifically mentioned in the transcript
5. Don't use unsupported packages

Use this exact structure:

\\documentclass[12pt,a4paper]{article}
\\usepackage[utf8]{inputenc}
\\usepackage{amsmath}
\\usepackage[margin=2.5cm]{geometry}

\\title{[COURSE_NAME]}
\\author{Generated by LectureMate}
\\date{\\today}

\\begin{document}

\\maketitle

[CONTENT]

\\end{document}"""
    
    try:
        print("Sending request to OpenAI API...")
        response = client.chat.completions.create(
            model="gpt-4o-mini-2024-07-18",  # Using 4o mini model
            messages=[
                {"role": "system", "content": system_msg},
                {"role": "user", "content": f"Create a comprehensive lecture summary in LaTeX format. Include all technical details, examples, and practical applications. Use proper LaTeX sectioning and formatting:\n\n{text}"}
            ],
            max_tokens=4096,
            temperature=0.2
        )
        
        print("Received response from OpenAI API")
        content = response.choices[0].message.content
        
        # Clean up the LaTeX content
        content = content.replace("```latex", "").replace("```", "")
        content = content.replace("[COURSE_NAME]", course_name)
        
        return content
    except Exception as e:
        print(f"Error getting summary from ChatGPT: {str(e)}")
        return None

def find_pdflatex():
    """Find pdflatex executable in common installation paths"""
    possible_paths = [
        r"C:\Users\kaand\AppData\Local\Programs\MiKTeX\miktex\bin\x64\pdflatex.exe",  # Your specific installation
        r"C:\texlive\2023\bin\windows\pdflatex.exe",
        r"C:\Program Files\MiKTeX\miktex\bin\x64\pdflatex.exe",
        r"C:\Users\Administrator\AppData\Local\Programs\MiKTeX\miktex\bin\x64\pdflatex.exe",
        r"C:\Program Files (x86)\MiKTeX\miktex\bin\pdflatex.exe"
    ]
    
    for path in possible_paths:
        if os.path.exists(path):
            return path
            
    return None

def generate_pdf(latex_file):
    """Generate PDF from LaTeX file using MiKTeX or TeXLive"""
    try:
        print("Generating PDF...")
        # Change to the directory containing the latex file
        latex_dir = os.path.dirname(latex_file)
        original_dir = os.getcwd()
        os.chdir(latex_dir)
        
        # Get just the filename without path
        latex_filename = os.path.basename(latex_file)
        
        # Find pdflatex
        pdflatex_path = find_pdflatex()
        if not pdflatex_path:
            print("Error: pdflatex not found in common installation paths")
            print("Please ensure LaTeX (MiKTeX or TeXLive) is installed")
            return False
            
        print(f"Using pdflatex at: {pdflatex_path}")
        
        # Run pdflatex twice to resolve references
        for i in range(2):
            result = subprocess.run(
                [pdflatex_path, '-interaction=nonstopmode', latex_filename],
                capture_output=True,
                text=True
            )
            if result.returncode != 0:
                print("LaTeX Error Output:")
                print(result.stdout)  # Show stdout which often contains the actual error
                print("\nLaTeX Error Details:")
                print(result.stderr)
                os.chdir(original_dir)
                return False
        
        # Clean up auxiliary files
        for ext in ['.aux', '.log', '.out']:
            aux_file = latex_filename.replace('.tex', ext)
            if os.path.exists(aux_file):
                os.remove(aux_file)
        
        # Change back to original directory
        os.chdir(original_dir)
        return True
    except Exception as e:
        print(f"Error generating PDF: {str(e)}")
        os.chdir(original_dir)
        return False

def summarize_transcript(transcript_text, output_pdf_path, course_name, lecture_title, client, temp_dir):
    """Summarize a single transcript and save as PDF"""
    try:
        # Get LaTeX summary
        latex_content = get_summary(transcript_text, client, f"{course_name} - {lecture_title}")
        if not latex_content:
            print(f"Failed to get summary for {lecture_title}")
            return False
            
        # Create temporary LaTeX file
        temp_latex_file = os.path.join(temp_dir, f"{lecture_title}.tex")
        try:
            with open(temp_latex_file, 'w', encoding='utf-8') as f:
                f.write(latex_content)
            print(f"Created temporary LaTeX file")
            
            # Generate PDF
            if generate_pdf(temp_latex_file):
                # Move PDF to final location
                temp_pdf = temp_latex_file.replace('.tex', '.pdf')
                if os.path.exists(temp_pdf):
                    import shutil
                    os.makedirs(os.path.dirname(output_pdf_path), exist_ok=True)
                    shutil.move(temp_pdf, output_pdf_path)
                    print(f"Saved PDF to: {output_pdf_path}")
                else:
                    print("Error: PDF file not found after generation")
                    return False
            else:
                print("Failed to generate PDF")
                return False
                
            # Clean up temporary LaTeX file
            if os.path.exists(temp_latex_file):
                os.remove(temp_latex_file)
                
        except Exception as e:
            print(f"Error in PDF generation process: {str(e)}")
            # Clean up temporary files
            if os.path.exists(temp_latex_file):
                os.remove(temp_latex_file)
            return False
            
        return True
    except Exception as e:
        print(f"Error summarizing transcript: {str(e)}")
        return False

def setup_openai_client():
    """Setup and test OpenAI client"""
    # Load API key from .env file
    load_dotenv()
    api_key = os.getenv('OPENAI_API_KEY')
    
    if not api_key:
        print("Error: No API key found in .env file")
        return None
    
    # Validate and clean API key
    api_key = validate_api_key(api_key)
    
    # Initialize OpenAI client
    client = OpenAI(api_key=api_key)
    
    # Test API connection
    print("Testing API connection...")
    if not test_api_connection(client):
        print("Failed to connect to OpenAI API. Please check your API key and try again.")
        return None
    print("API connection successful!")
    
    return client

def process_course_folder(course_path, client):
    """Process all transcripts in a course folder"""
    # Convert to absolute path
    course_path = os.path.abspath(course_path)
    clean_dir = os.path.join(course_path, "clean")
    
    if not os.path.exists(clean_dir):
        print(f"No clean transcripts found in {clean_dir}")
        return
        
    # Create summaries directory for PDFs
    summaries_dir = os.path.join(course_path, "summaries")
    pdf_dir = os.path.join(summaries_dir, "pdf")
    os.makedirs(pdf_dir, exist_ok=True)
    
    # Create a temporary directory for LaTeX processing
    temp_dir = os.path.join(summaries_dir, "temp")
    os.makedirs(temp_dir, exist_ok=True)
    
    # Get all txt files and sort them by date
    txt_files = [f for f in os.listdir(clean_dir) if f.endswith('.txt')]
    txt_files.sort()  # This will sort by date since filenames start with dates
    
    if not txt_files:
        print(f"No transcript files found in {clean_dir}")
        return
        
    course_name = os.path.basename(course_path)
    print(f"\nProcessing {len(txt_files)} transcripts for {course_name}")
    
    for txt_file in txt_files:
        # Get week/lecture title from filename
        lecture_title = txt_file.replace('.txt', '')
        
        # Define output PDF file
        pdf_file = os.path.join(pdf_dir, txt_file.replace('.txt', '.pdf'))
        
        # Skip if PDF already exists
        if os.path.exists(pdf_file):
            print(f"\nPDF already exists for {txt_file}, skipping...")
            continue
        
        print(f"\nProcessing: {txt_file}")
        
        # Read transcript
        try:
            transcript_file = os.path.join(clean_dir, txt_file)
            with open(transcript_file, 'r', encoding='utf-8') as f:
                transcript = f.read()
                print(f"Read transcript file: {len(transcript)} characters")
                
            # Summarize and save PDF
            summarize_transcript(transcript, pdf_file, course_name, lecture_title, client, temp_dir)
            
            # Sleep to avoid hitting API rate limits
            time.sleep(1)
            
        except Exception as e:
            print(f"Error reading transcript file: {str(e)}")
            continue
            
    # Clean up temporary directory
    try:
        import shutil
        shutil.rmtree(temp_dir)
    except Exception as e:
        print(f"Warning: Could not clean up temporary directory: {str(e)}")

def main():
    parser = argparse.ArgumentParser(description='Summarize lecture transcripts using ChatGPT')
    parser.add_argument('--api-key', help='OpenAI API key (optional if set in .env file)')
    parser.add_argument('--path', default='default_out_path', help='Path containing course folders')
    args = parser.parse_args()
    
    # Load API key from .env file if not provided as argument
    load_dotenv()
    api_key = args.api_key or os.getenv('OPENAI_API_KEY')
    
    if not api_key:
        print("Error: No API key provided. Either use --api-key argument or set OPENAI_API_KEY in .env file")
        sys.exit(1)
    
    # Validate and clean API key
    api_key = validate_api_key(api_key)
    
    # Initialize OpenAI client
    client = OpenAI(api_key=api_key)
    
    # Test API connection
    print("Testing API connection...")
    if not test_api_connection(client):
        print("Failed to connect to OpenAI API. Please check your API key and try again.")
        sys.exit(1)
    print("API connection successful!")
    
    # Check if path exists
    if not os.path.exists(args.path):
        print(f"Error: Path {args.path} does not exist")
        sys.exit(1)
        
    # Process each course folder
    course_folders = [f for f in os.listdir(args.path) 
                     if os.path.isdir(os.path.join(args.path, f))]
    
    if not course_folders:
        print(f"No course folders found in {args.path}")
        sys.exit(1)
        
    print(f"Found {len(course_folders)} course folders")
    
    for course_folder in course_folders:
        course_path = os.path.join(args.path, course_folder)
        print(f"\nProcessing course: {course_folder}")
        process_course_folder(course_path, client)
        
    print("\nDone!")

if __name__ == "__main__":
    main() 